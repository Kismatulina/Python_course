# Знакомство с языком Python (семинары)
# Урок 7. Функции высшего порядка

# разбор лекции  map и lambda:
# def func(x: int) -> int:   # была такая функция , а стала в две строчки:
#     return x**4
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # 
# for i in range(len(values)):
#     values[i] = func(values[i])
# print(values) # вывел [16, 81, 625, 2401, 14641, 28561, 83521, 130321, 279841, 707281]

# print(list(map(func, values)))  # map прогнал через функцию наш список [16, 81, 625, 2401, 14641, 28561, 83521, 130321, 279841, 707281]

# func = lambda x: x**4 # написали анонимную функцию, все так же выводит в 4 степени, и тогда не надо имя func заводить, просто сразу в принте 

# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] #  # функция стала в две строчки:
# print(list(map(lambda x: x**4, values))) # [16, 81, 625, 2401, 14641, 28561, 83521, 130321, 279841, 707281] функцию прям сюда записали, убрали лишнию ячейку func

# задача 47
# У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине
# программы используется множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - посредством задания
# функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
# список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
# копией values.
# пример не поняла:
# values = [1, 23, 42, ‘asdfg’]
# transformed_values = list(map(trasformation, values))
# if values == transformed_values:
#  print(‘ok’)
# else:
#  print(‘fail’)

# transformation = <???>   # что сюда вставить?
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# print(transormed_values == values)

# transformation = lambda x: x              # <???> чтобы сделать анонимной, не надо сюда присваивать, ниже убираем в скобки 
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
# transormed_values = list(map(transformation, values))
# print(transormed_values == values)

# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
# transormed_values = list(map(lambda x: x, values))        # делает ее анонимной, убираем просто внутрь, чтобы отдельно не писать
# print(transormed_values == values)


# Задача №49 
# Планеты вращаются вокруг звезд по эллиптическим орбитам.
# Назовем самой далекой планетой ту, орбита которой имеет
# самую большую площадь. Напишите функцию
# find_farthest_orbit(list_of_orbits), которая среди списка орбит
# планет найдет ту, по которой вращается самая далекая
# планета. Круговые орбиты не учитывайте: вы знаете, что у
# вашей звезды таких планет нет, зато искусственные спутники
# были были запущены на круговые орбиты. Результатом
# функции должен быть кортеж, содержащий длины полуосей
# эллипса орбиты самой далекой планеты. Каждая орбита
# представляет из себя кортеж из пары чисел - полуосей ее
# эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b,
# где a и b - длины полуосей эллипса. При решении задачи
# используйте списочные выражения. Подсказка: проще всего
# будет найти эллипс в два шага: сначала вычислить самую
# большую площадь эллипса, а затем найти и сам эллипс,
# имеющий такую площадь. Гарантируется, что самая далекая
# планета ровно одна
# ввод:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))
# ввывод:
# 2.5, 10

# Святослав Миловидов генерируем новый список:
# list_old = [2, 4, 7, 12]
# list_new = []

# Вариант 1 (если есть цикл)
#                что сделать           где взять          *при каком условии
# list_new = [(0 if num < 5 else num) for num in list_old if num > 5]  # включениями в одну строку с for  (что сделать-попадет в итогвый спск) если генерировать числа , то через включения 

# Вариант 2 (видите фор , если в одну строчку, то можно использовать синткс сахар -вар 1 или 3)
# for num in list_old:
#     list_new.append(0 if num < 5 else num) # тернарный оператор меняем на нолик если номер меньше 5 иначе пишем номер из старгог списка

# Вариант 3 (если есть цикл)
# list_new = list(map(lambda num: 0 if num < 5 else num, list_old)) # сделали в одну строку через list- map-lambda

# print(list_new)



# Решение 49 : поэтапное объяснение
# def find_farthest_orbit(orbits):   # просят написать эту функцию и найти площади
#     s = [dbl[0] * dbl[1] for dbl in orbits] # что сделать, чтобы сразу получить площади? и где это взять?получили площади[3, 25.0, 14, 36, 12]
#     print(s)  #  [3, 25.0, 14, 36, 12]

# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# find_farthest_orbit(orbits)

# это мы решали сами на уроке:
# res = 0
# maxim = 0
# for i in range(len(orbits)):
#     if orbits[i][0] != orbits[i][1]:
#         res = orbits[i][0] * orbits[i][1]
#         if res > maxim:
#             maxim = res
#             max_i = (orbits[i][0],orbits[i][1])
# # print (maxim)
# print (max_i)

def find_farthest_orbit(orbits): # итоговое решение , мы не смогли преобразовать наше решение
    s = [(dbl[0]*dbl[1] if dbl[0]!=dbl[1] else 0) for dbl in orbits] #занулим пару которая явл спутником,перемножить если выполняется это условие, а иначе написать о ноль,(перемножим если они не равны) 
    return orbits[s.index(max(s))] #нашли мах из площади, узнали его индекс, и вывели (2.5, 10) 

orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
print(*find_farthest_orbit(orbits)) # 2.5 10 *звездочка распаковывет кортеж (скобки убирает) 



# Денис Дворников
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# find_farthest_orbit=list(map(lambda x :0 if x[1]==x[0] else x[0]*x[1], orbits))
# i=find_farthest_orbit.index(max(find_farthest_orbit))
# print(orbits[i])

# Я вот ещё такое решение 70нашёл, где только orbits нужен, без указания функции
# print(max(orbits, key = lambda x: x[0] * x[1] if x[0] != x[1] else 0))
# пока это не надо, крутое


# зад 51
# Напишите функцию same_by(characteristic, objects), которая
# проверяет, все ли объекты имеют одинаковое значение
# некоторой характеристики, и возвращают True, если это так.
# Если значение характеристики для разных объектов
# отличается - то False. Для пустого набора объектов, функция
# должна возвращать True. Аргумент characteristic - это
# функция, которая принимает объект и вычисляет его
# характеристику.
# Ввод:                                            Вывод:
# values = [0, 2, 10, 6]                           same
# if same_by(lambda x: x % 2, values):
# print(‘same’)
# else:
# print(‘different’)
# Решение:


# def same_by(func, vals):
#     return len(set(map(func, vals))) in [0, 1] # map(func, vals) выведит 0,0,0,0$ f set выведит уникальные не повторяющиеся значения множества
                     

# values = [0, 2, 10, 7]
# if same_by(lambda x: x % 2, values):
#     print('same')
# else:
#     print('different')